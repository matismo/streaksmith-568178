use client\n\nimport { useAccount, useConnect, useDisconnect, useReadContract, useWriteContract } from "wagmi";\nimport { useMemo, useState } from "react";\n\nconst contractAddress = "0x9Be286c48445acacADC282d6c283C3F5d5Ff97cE" as const;\n\nconst abi = [\n  { type: "function", name: "name", stateMutability: "view", inputs: [], outputs: [{ type: "string" }] },\n  { type: "function", name: "symbol", stateMutability: "view", inputs: [], outputs: [{ type: "string" }] },\n  { type: "function", name: "owner", stateMutability: "view", inputs: [], outputs: [{ type: "address" }] },\n  { type: "function", name: "totalSupply", stateMutability: "view", inputs: [], outputs: [{ type: "uint256" }] },\n  { type: "function", name: "baseURI", stateMutability: "view", inputs: [], outputs: [{ type: "string" }] },\n  { type: "function", name: "mintNext", stateMutability: "nonpayable", inputs: [{ name: "to", type: "address" }], outputs: [{ type: "uint256" }] },\n];\n\nexport default function Page() {\n  const { address, isConnected } = useAccount();\n  const { connect, connectors } = useConnect();\n  const { disconnect } = useDisconnect();\n  const { writeContractAsync, isPending } = useWriteContract();\n  const [mintTo, setMintTo] = useState<string>("");\n\n  const { data: name } = useReadContract({ address: contractAddress, abi, functionName: "name" });\n  const { data: symbol } = useReadContract({ address: contractAddress, abi, functionName: "symbol" });\n  const { data: owner } = useReadContract({ address: contractAddress, abi, functionName: "owner" });\n  const { data: totalSupply } = useReadContract({ address: contractAddress, abi, functionName: "totalSupply" });\n  const { data: baseURI } = useReadContract({ address: contractAddress, abi, functionName: "baseURI" });\n\n  const isOwner = useMemo(() => {\n    if (!owner || !address) return false;\n    return owner.toLowerCase() === address.toLowerCase();\n  }, [owner, address]);\n\n  async function handleMint() {\n    const to = mintTo || address;\n    if (!to) return;\n    await writeContractAsync({\n      address: contractAddress,\n      abi,\n      functionName: "mintNext",\n      args: [to],\n    });\n  }\n\n  return (\n    <main className="page">\n      <header className="hero">\n        <div>\n          <p className="eyebrow">StreakSmith</p>\n          <h1>Turn daily usage into proof</h1>\n          <p className="subtitle">Retention is slipping. Give users a reason to come back every day.</p>\n          <div className="cta-row">\n            {!isConnected ? (\n              <button className="btn" onClick={() => connect({ connector: connectors[0] })}>Connect wallet</button>\n            ) : (\n              <button className="btn ghost" onClick={() => disconnect()}>Disconnect</button>\n            )}\n            <a className="btn ghost" href="https://sepolia.basescan.org/address/0x9Be286c48445acacADC282d6c283C3F5d5Ff97cE" target="_blank">View contract</a>\n          </div>\n        </div>\n        <div className="glass">\n          <h3>Onchain snapshot</h3>\n          <div className="grid">\n            <div><span>Name</span><strong>{String(name || "—")}</strong></div>\n            <div><span>Symbol</span><strong>{String(symbol || "—")}</strong></div>\n            <div><span>Total supply</span><strong>{totalSupply ? totalSupply.toString() : "—"}</strong></div>\n            <div><span>Owner</span><strong className="mono">{owner ? String(owner) : "—"}</strong></div>\n            <div className="wide"><span>Base URI</span><strong className="mono">{String(baseURI || "—")}</strong></div>\n          </div>\n        </div>\n      </header>\n\n      <section className="section">\n        <h2>Why it exists</h2>\n        <p>Base daily actives and onboarding cooled in recent data. StreakSmith gives builders a retention lever that turns repeat usage into onchain badges.</p>\n      </section>\n\n      <section className="section">\n        <h2>What shipped</h2>\n        <div className="cards">\n          <div className="card">Wallet login with Base</div>\n          <div className="card">Daily streak tracking and reset logic</div>\n          <div className="card">Mintable onchain streak badges</div>\n          <div className="card">Cohort view for new vs returning users</div>\n          <div className="card">Lightweight activity feed</div>\n        </div>\n      </section>\n\n      <section className="section">\n        <h2>Owner mint</h2>\n        <p>Only the contract owner can mint streak badges. Connect the owner wallet to enable minting.</p>\n        <div className="mint">\n          <input\n            className="input"\n            placeholder="Recipient address (defaults to connected wallet)"\n            value={mintTo}\n            onChange={(e) => setMintTo(e.target.value)}\n          />\n          <button className="btn" disabled={!isConnected || !isOwner || isPending} onClick={handleMint}>\n            {isPending ? "Minting…" : "Mint badge"}\n          </button>\n        </div>\n        {!isOwner && isConnected && <p className="hint">Connect the owner wallet to mint.</p>}\n      </section>\n\n      <footer className="footer">\n        <span>Network: Base Sepolia</span>\n        {isConnected && <span className="mono">Connected: {address}</span>}\n      </footer>\n    </main>\n  );\n}